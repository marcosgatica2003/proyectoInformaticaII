.TH "MFRC522Extended" 3 "Sistema de seguridad en cámaras frigoríficas" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MFRC522Extended
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <MFRC522Extended\&.h>\fP
.PP
Hereda de \fBMFRC522\fP\&.
.SS "Estructuras de datos"

.in +1c
.ti -1c
.RI "struct \fBAts\fP"
.br
.ti -1c
.RI "struct \fBAts\&.ta1\fP"
.br
.ti -1c
.RI "struct \fBAts\&.tb1\fP"
.br
.ti -1c
.RI "struct \fBAts\&.tc1\fP"
.br
.ti -1c
.RI "struct \fBPcbBlock\fP"
.br
.ti -1c
.RI "struct \fBPcbBlock\&.inf\fP"
.br
.ti -1c
.RI "struct \fBPcbBlock\&.prologue\fP"
.br
.ti -1c
.RI "struct \fBTagInfo\fP"
.br
.in -1c
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "enum \fBTagBitRates\fP : byte { \fBBITRATE_106KBITS\fP = 0x00, \fBBITRATE_212KBITS\fP = 0x01, \fBBITRATE_424KBITS\fP = 0x02, \fBBITRATE_848KBITS\fP = 0x03 }"
.br
.in -1c

Tipos públicos heredados de \fBMFRC522\fP
.in +1c
.ti -1c
.RI "enum \fBPCD_Register\fP : byte { \fBCommandReg\fP = 0x01 << 1, \fBComIEnReg\fP = 0x02 << 1, \fBDivIEnReg\fP = 0x03 << 1, \fBComIrqReg\fP = 0x04 << 1, \fBDivIrqReg\fP = 0x05 << 1, \fBErrorReg\fP = 0x06 << 1, \fBStatus1Reg\fP = 0x07 << 1, \fBStatus2Reg\fP = 0x08 << 1, \fBFIFODataReg\fP = 0x09 << 1, \fBFIFOLevelReg\fP = 0x0A << 1, \fBWaterLevelReg\fP = 0x0B << 1, \fBControlReg\fP = 0x0C << 1, \fBBitFramingReg\fP = 0x0D << 1, \fBCollReg\fP = 0x0E << 1, \fBModeReg\fP = 0x11 << 1, \fBTxModeReg\fP = 0x12 << 1, \fBRxModeReg\fP = 0x13 << 1, \fBTxControlReg\fP = 0x14 << 1, \fBTxASKReg\fP = 0x15 << 1, \fBTxSelReg\fP = 0x16 << 1, \fBRxSelReg\fP = 0x17 << 1, \fBRxThresholdReg\fP = 0x18 << 1, \fBDemodReg\fP = 0x19 << 1, \fBMfTxReg\fP = 0x1C << 1, \fBMfRxReg\fP = 0x1D << 1, \fBSerialSpeedReg\fP = 0x1F << 1, \fBCRCResultRegH\fP = 0x21 << 1, \fBCRCResultRegL\fP = 0x22 << 1, \fBModWidthReg\fP = 0x24 << 1, \fBRFCfgReg\fP = 0x26 << 1, \fBGsNReg\fP = 0x27 << 1, \fBCWGsPReg\fP = 0x28 << 1, \fBModGsPReg\fP = 0x29 << 1, \fBTModeReg\fP = 0x2A << 1, \fBTPrescalerReg\fP = 0x2B << 1, \fBTReloadRegH\fP = 0x2C << 1, \fBTReloadRegL\fP = 0x2D << 1, \fBTCounterValueRegH\fP = 0x2E << 1, \fBTCounterValueRegL\fP = 0x2F << 1, \fBTestSel1Reg\fP = 0x31 << 1, \fBTestSel2Reg\fP = 0x32 << 1, \fBTestPinEnReg\fP = 0x33 << 1, \fBTestPinValueReg\fP = 0x34 << 1, \fBTestBusReg\fP = 0x35 << 1, \fBAutoTestReg\fP = 0x36 << 1, \fBVersionReg\fP = 0x37 << 1, \fBAnalogTestReg\fP = 0x38 << 1, \fBTestDAC1Reg\fP = 0x39 << 1, \fBTestDAC2Reg\fP = 0x3A << 1, \fBTestADCReg\fP = 0x3B << 1 }"
.br
.ti -1c
.RI "enum \fBPCD_Command\fP : byte { \fBPCD_Idle\fP = 0x00, \fBPCD_Mem\fP = 0x01, \fBPCD_GenerateRandomID\fP = 0x02, \fBPCD_CalcCRC\fP = 0x03, \fBPCD_Transmit\fP = 0x04, \fBPCD_NoCmdChange\fP = 0x07, \fBPCD_Receive\fP = 0x08, \fBPCD_Transceive\fP = 0x0C, \fBPCD_MFAuthent\fP = 0x0E, \fBPCD_SoftReset\fP = 0x0F }"
.br
.ti -1c
.RI "enum \fBPCD_RxGain\fP : byte { \fBRxGain_18dB\fP = 0x00 << 4, \fBRxGain_23dB\fP = 0x01 << 4, \fBRxGain_18dB_2\fP = 0x02 << 4, \fBRxGain_23dB_2\fP = 0x03 << 4, \fBRxGain_33dB\fP = 0x04 << 4, \fBRxGain_38dB\fP = 0x05 << 4, \fBRxGain_43dB\fP = 0x06 << 4, \fBRxGain_48dB\fP = 0x07 << 4, \fBRxGain_min\fP = 0x00 << 4, \fBRxGain_avg\fP = 0x04 << 4, \fBRxGain_max\fP = 0x07 << 4 }"
.br
.ti -1c
.RI "enum \fBPICC_Command\fP : byte { \fBPICC_CMD_REQA\fP = 0x26, \fBPICC_CMD_WUPA\fP = 0x52, \fBPICC_CMD_CT\fP = 0x88, \fBPICC_CMD_SEL_CL1\fP = 0x93, \fBPICC_CMD_SEL_CL2\fP = 0x95, \fBPICC_CMD_SEL_CL3\fP = 0x97, \fBPICC_CMD_HLTA\fP = 0x50, \fBPICC_CMD_RATS\fP = 0xE0, \fBPICC_CMD_MF_AUTH_KEY_A\fP = 0x60, \fBPICC_CMD_MF_AUTH_KEY_B\fP = 0x61, \fBPICC_CMD_MF_READ\fP = 0x30, \fBPICC_CMD_MF_WRITE\fP = 0xA0, \fBPICC_CMD_MF_DECREMENT\fP = 0xC0, \fBPICC_CMD_MF_INCREMENT\fP = 0xC1, \fBPICC_CMD_MF_RESTORE\fP = 0xC2, \fBPICC_CMD_MF_TRANSFER\fP = 0xB0, \fBPICC_CMD_UL_WRITE\fP = 0xA2 }"
.br
.ti -1c
.RI "enum \fBMIFARE_Misc\fP { \fBMF_ACK\fP = 0xA, \fBMF_KEY_SIZE\fP = 6 }"
.br
.ti -1c
.RI "enum \fBPICC_Type\fP : byte { \fBPICC_TYPE_UNKNOWN\fP, \fBPICC_TYPE_ISO_14443_4\fP, \fBPICC_TYPE_ISO_18092\fP, \fBPICC_TYPE_MIFARE_MINI\fP, \fBPICC_TYPE_MIFARE_1K\fP, \fBPICC_TYPE_MIFARE_4K\fP, \fBPICC_TYPE_MIFARE_UL\fP, \fBPICC_TYPE_MIFARE_PLUS\fP, \fBPICC_TYPE_MIFARE_DESFIRE\fP, \fBPICC_TYPE_TNP3XXX\fP, \fBPICC_TYPE_NOT_COMPLETE\fP = 0xff }"
.br
.ti -1c
.RI "enum \fBStatusCode\fP : byte { \fBSTATUS_OK\fP, \fBSTATUS_ERROR\fP, \fBSTATUS_COLLISION\fP, \fBSTATUS_TIMEOUT\fP, \fBSTATUS_NO_ROOM\fP, \fBSTATUS_INTERNAL_ERROR\fP, \fBSTATUS_INVALID\fP, \fBSTATUS_CRC_WRONG\fP, \fBSTATUS_MIFARE_NACK\fP = 0xff }"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "\fBMFRC522Extended\fP (uint8_t rst)"
.br
.ti -1c
.RI "\fBMFRC522Extended\fP (uint8_t ss, uint8_t rst)"
.br
.ti -1c
.RI "StatusCode \fBPICC_Select\fP (\fBUid\fP *uid, byte validBits=0) override"
.br
.ti -1c
.RI "StatusCode \fBPICC_RequestATS\fP (\fBAts\fP *ats)"
.br
.ti -1c
.RI "StatusCode \fBPICC_PPS\fP ()"
.br
.ti -1c
.RI "StatusCode \fBPICC_PPS\fP (TagBitRates sendBitRate, TagBitRates receiveBitRate)"
.br
.ti -1c
.RI "StatusCode \fBTCL_Transceive\fP (\fBPcbBlock\fP *send, \fBPcbBlock\fP *back)"
.br
.ti -1c
.RI "StatusCode \fBTCL_Transceive\fP (\fBTagInfo\fP *tag, byte *sendData, byte sendLen, byte *backData=NULL, byte *backLen=NULL)"
.br
.ti -1c
.RI "StatusCode \fBTCL_TransceiveRBlock\fP (\fBTagInfo\fP *tag, bool ack, byte *backData=NULL, byte *backLen=NULL)"
.br
.ti -1c
.RI "StatusCode \fBTCL_Deselect\fP (\fBTagInfo\fP *tag)"
.br
.ti -1c
.RI "void \fBPICC_DumpToSerial\fP (\fBTagInfo\fP *tag)"
.br
.ti -1c
.RI "void \fBPICC_DumpDetailsToSerial\fP (\fBTagInfo\fP *tag)"
.br
.ti -1c
.RI "void \fBPICC_DumpISO14443_4\fP (\fBTagInfo\fP *tag)"
.br
.ti -1c
.RI "bool \fBPICC_IsNewCardPresent\fP () override"
.br
.ti -1c
.RI "bool \fBPICC_ReadCardSerial\fP () override"
.br
.ti -1c
.RI "void \fBPICC_DumpToSerial\fP (\fBUid\fP *uid)"
.br
.ti -1c
.RI "void \fBPICC_DumpDetailsToSerial\fP (\fBUid\fP *uid)"
.br
.in -1c

Métodos públicos heredados de \fBMFRC522\fP
.in +1c
.ti -1c
.RI "\fBMFRC522\fP ()"
.br
.ti -1c
.RI "\fBMFRC522\fP (byte resetPowerDownPin)"
.br
.ti -1c
.RI "\fBMFRC522\fP (byte chipSelectPin, byte resetPowerDownPin)"
.br
.ti -1c
.RI "void \fBPCD_WriteRegister\fP (PCD_Register reg, byte value)"
.br
.ti -1c
.RI "void \fBPCD_WriteRegister\fP (PCD_Register reg, byte count, byte *values)"
.br
.ti -1c
.RI "byte \fBPCD_ReadRegister\fP (PCD_Register reg)"
.br
.ti -1c
.RI "void \fBPCD_ReadRegister\fP (PCD_Register reg, byte count, byte *values, byte rxAlign=0)"
.br
.ti -1c
.RI "void \fBPCD_SetRegisterBitMask\fP (PCD_Register reg, byte mask)"
.br
.ti -1c
.RI "void \fBPCD_ClearRegisterBitMask\fP (PCD_Register reg, byte mask)"
.br
.ti -1c
.RI "StatusCode \fBPCD_CalculateCRC\fP (byte *data, byte length, byte *result)"
.br
.ti -1c
.RI "void \fBPCD_Init\fP ()"
.br
.ti -1c
.RI "void \fBPCD_Init\fP (byte resetPowerDownPin)"
.br
.ti -1c
.RI "void \fBPCD_Init\fP (byte chipSelectPin, byte resetPowerDownPin)"
.br
.ti -1c
.RI "void \fBPCD_Reset\fP ()"
.br
.ti -1c
.RI "void \fBPCD_AntennaOn\fP ()"
.br
.ti -1c
.RI "void \fBPCD_AntennaOff\fP ()"
.br
.ti -1c
.RI "byte \fBPCD_GetAntennaGain\fP ()"
.br
.ti -1c
.RI "void \fBPCD_SetAntennaGain\fP (byte mask)"
.br
.ti -1c
.RI "bool \fBPCD_PerformSelfTest\fP ()"
.br
.ti -1c
.RI "void \fBPCD_SoftPowerDown\fP ()"
.br
.ti -1c
.RI "void \fBPCD_SoftPowerUp\fP ()"
.br
.ti -1c
.RI "StatusCode \fBPCD_TransceiveData\fP (byte *sendData, byte sendLen, byte *backData, byte *backLen, byte *validBits=nullptr, byte rxAlign=0, bool checkCRC=false)"
.br
.ti -1c
.RI "StatusCode \fBPCD_CommunicateWithPICC\fP (byte command, byte waitIRq, byte *sendData, byte sendLen, byte *backData=nullptr, byte *backLen=nullptr, byte *validBits=nullptr, byte rxAlign=0, bool checkCRC=false)"
.br
.ti -1c
.RI "StatusCode \fBPICC_RequestA\fP (byte *bufferATQA, byte *bufferSize)"
.br
.ti -1c
.RI "StatusCode \fBPICC_WakeupA\fP (byte *bufferATQA, byte *bufferSize)"
.br
.ti -1c
.RI "StatusCode \fBPICC_REQA_or_WUPA\fP (byte command, byte *bufferATQA, byte *bufferSize)"
.br
.ti -1c
.RI "StatusCode \fBPICC_HaltA\fP ()"
.br
.ti -1c
.RI "StatusCode \fBPCD_Authenticate\fP (byte command, byte blockAddr, \fBMIFARE_Key\fP *key, \fBUid\fP *uid)"
.br
.ti -1c
.RI "void \fBPCD_StopCrypto1\fP ()"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_Read\fP (byte blockAddr, byte *buffer, byte *bufferSize)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_Write\fP (byte blockAddr, byte *buffer, byte bufferSize)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_Ultralight_Write\fP (byte page, byte *buffer, byte bufferSize)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_Decrement\fP (byte blockAddr, int32_t delta)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_Increment\fP (byte blockAddr, int32_t delta)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_Restore\fP (byte blockAddr)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_Transfer\fP (byte blockAddr)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_GetValue\fP (byte blockAddr, int32_t *value)"
.br
.ti -1c
.RI "StatusCode \fBMIFARE_SetValue\fP (byte blockAddr, int32_t value)"
.br
.ti -1c
.RI "StatusCode \fBPCD_NTAG216_AUTH\fP (byte *passWord, byte pACK[])"
.br
.ti -1c
.RI "StatusCode \fBPCD_MIFARE_Transceive\fP (byte *sendData, byte sendLen, bool acceptTimeout=false)"
.br
.ti -1c
.RI "void \fBPCD_DumpVersionToSerial\fP ()"
.br
.ti -1c
.RI "void \fBPICC_DumpToSerial\fP (\fBUid\fP *uid)"
.br
.ti -1c
.RI "void \fBPICC_DumpDetailsToSerial\fP (\fBUid\fP *uid)"
.br
.ti -1c
.RI "void \fBPICC_DumpMifareClassicToSerial\fP (\fBUid\fP *uid, PICC_Type piccType, \fBMIFARE_Key\fP *key)"
.br
.ti -1c
.RI "void \fBPICC_DumpMifareClassicSectorToSerial\fP (\fBUid\fP *uid, \fBMIFARE_Key\fP *key, byte sector)"
.br
.ti -1c
.RI "void \fBPICC_DumpMifareUltralightToSerial\fP ()"
.br
.ti -1c
.RI "void \fBMIFARE_SetAccessBits\fP (byte *accessBitBuffer, byte g0, byte g1, byte g2, byte g3)"
.br
.ti -1c
.RI "bool \fBMIFARE_OpenUidBackdoor\fP (bool logErrors)"
.br
.ti -1c
.RI "bool \fBMIFARE_SetUid\fP (byte *newUid, byte uidSize, bool logErrors)"
.br
.ti -1c
.RI "bool \fBMIFARE_UnbrickUidSector\fP (bool logErrors)"
.br
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static PICC_Type \fBPICC_GetType\fP (\fBTagInfo\fP *tag)"
.br
.ti -1c
.RI "static PICC_Type \fBPICC_GetType\fP (byte sak)"
.br
.in -1c

Métodos públicos estáticos heredados de \fBMFRC522\fP
.in +1c
.ti -1c
.RI "static const __FlashStringHelper * \fBGetStatusCodeName\fP (StatusCode code)"
.br
.ti -1c
.RI "static PICC_Type \fBPICC_GetType\fP (byte sak)"
.br
.ti -1c
.RI "static const __FlashStringHelper * \fBPICC_GetTypeName\fP (PICC_Type type)"
.br
.in -1c
.SS "Campos de datos"

.in +1c
.ti -1c
.RI "\fBTagInfo\fP \fBtag\fP"
.br
.in -1c

Campos de datos heredados de \fBMFRC522\fP
.in +1c
.ti -1c
.RI "\fBUid\fP \fBuid\fP"
.br
.in -1c
.SS "Otros miembros heredados"


Atributos públicos estáticos heredados de \fBMFRC522\fP
.in +1c
.ti -1c
.RI "static constexpr byte \fBFIFO_SIZE\fP = 64"
.br
.ti -1c
.RI "static constexpr uint8_t \fBUNUSED_PIN\fP = UINT8_MAX"
.br
.in -1c

Métodos protegidos heredados de \fBMFRC522\fP
.in +1c
.ti -1c
.RI "StatusCode \fBMIFARE_TwoStepHelper\fP (byte command, byte blockAddr, int32_t data)"
.br
.in -1c

Atributos protegidos heredados de \fBMFRC522\fP
.in +1c
.ti -1c
.RI "byte \fB_chipSelectPin\fP"
.br
.ti -1c
.RI "byte \fB_resetPowerDownPin\fP"
.br
.in -1c
.SH "Descripción detallada"
.PP 
Library extends \fBMFRC522\&.h\fP to support RATS for ISO-14443-4 PICC\&. RATS - Request for Answer To Select\&. 
.PP
\fBAutor\fP
.RS 4
JPG-Consulting 
.RE
.PP

.SH "Documentación de estructuras de datos"
.PP 
.SH "struct MFRC522Extended::Ats"
.PP 
\fBCampos de datos:\fP
.RS 4
byte \fIdata[FIFO_SIZE \- 2]\fP 
.br
.PP
byte \fIfsc\fP 
.br
.PP
byte \fIsize\fP 
.br
.PP
struct \fBAts\&.ta1\fP \fIta1\fP 
.br
.PP
struct \fBAts\&.tb1\fP \fItb1\fP 
.br
.PP
struct \fBAts\&.tc1\fP \fItc1\fP 
.br
.PP
.RE
.PP
.SH "struct MFRC522Extended::Ats\&.ta1"
.PP 
\fBCampos de datos:\fP
.RS 4
TagBitRates \fIdr\fP 
.br
.PP
TagBitRates \fIds\fP 
.br
.PP
bool \fIsameD\fP 
.br
.PP
bool \fItransmitted\fP 
.br
.PP
.RE
.PP
.SH "struct MFRC522Extended::Ats\&.tb1"
.PP 
\fBCampos de datos:\fP
.RS 4
byte \fIfwi\fP 
.br
.PP
byte \fIsfgi\fP 
.br
.PP
bool \fItransmitted\fP 
.br
.PP
.RE
.PP
.SH "struct MFRC522Extended::Ats\&.tc1"
.PP 
\fBCampos de datos:\fP
.RS 4
bool \fIsupportsCID\fP 
.br
.PP
bool \fIsupportsNAD\fP 
.br
.PP
bool \fItransmitted\fP 
.br
.PP
.RE
.PP
.SH "struct MFRC522Extended::PcbBlock"
.PP 
\fBCampos de datos:\fP
.RS 4
struct \fBPcbBlock\&.inf\fP \fIinf\fP 
.br
.PP
struct \fBPcbBlock\&.prologue\fP \fIprologue\fP 
.br
.PP
.RE
.PP
.SH "struct MFRC522Extended::PcbBlock\&.inf"
.PP 
\fBCampos de datos:\fP
.RS 4
byte * \fIdata\fP 
.br
.PP
byte \fIsize\fP 
.br
.PP
.RE
.PP
.SH "struct MFRC522Extended::PcbBlock\&.prologue"
.PP 
\fBCampos de datos:\fP
.RS 4
byte \fIcid\fP 
.br
.PP
byte \fInad\fP 
.br
.PP
byte \fIpcb\fP 
.br
.PP
.RE
.PP
.SH "struct MFRC522Extended::TagInfo"
.PP 
\fBCampos de datos:\fP
.RS 4
uint16_t \fIatqa\fP 
.br
.PP
\fBAts\fP \fIats\fP 
.br
.PP
bool \fIblockNumber\fP 
.br
.PP
\fBUid\fP \fIuid\fP 
.br
.PP
.RE
.PP
.SH "Documentación de funciones miembro"
.PP 
.SS "void MFRC522Extended::PICC_DumpDetailsToSerial (\fBTagInfo\fP * tag)"
Dumps card info (UID,SAK,Type) about the selected PICC to Serial\&. 
.PP
\fBParámetros\fP
.RS 4
\fItag\fP Pointer to \fBTagInfo\fP struct returned from a successful \fBPICC_Select()\fP\&. 
.RE
.PP

.SS "void MFRC522::PICC_DumpDetailsToSerial (\fBUid\fP * uid)"
Dumps card info (UID,SAK,Type) about the selected PICC to Serial\&. 
.PP
\fBParámetros\fP
.RS 4
\fIuid\fP Pointer to Uid struct returned from a successful \fBPICC_Select()\fP\&. 
.RE
.PP

.SS "void MFRC522Extended::PICC_DumpISO14443_4 (\fBTagInfo\fP * tag)"
Dumps memory contents of a ISO-14443-4 PICC\&. 
.SS "void MFRC522Extended::PICC_DumpToSerial (\fBTagInfo\fP * tag)"
Dumps debug info about the selected PICC to Serial\&. On success the PICC is halted after dumping the data\&. For MIFARE Classic the factory default key of 0xFFFFFFFFFFFF is tried\&. 
.SS "void MFRC522::PICC_DumpToSerial (\fBUid\fP * uid)"
Dumps debug info about the selected PICC to Serial\&. On success the PICC is halted after dumping the data\&. For MIFARE Classic the factory default key of 0xFFFFFFFFFFFF is tried\&. 
.br
 
.PP
\fBParámetros\fP
.RS 4
\fIuid\fP Pointer to Uid struct returned from a successful \fBPICC_Select()\fP\&. 
.RE
.PP

.SS "MFRC522::PICC_Type MFRC522::PICC_GetType (byte sak)\fR [static]\fP"
Translates the SAK (Select Acknowledge) to a PICC type\&.

.PP
\fBDevuelve\fP
.RS 4
PICC_Type 
.RE
.PP

.PP
\fBParámetros\fP
.RS 4
\fIsak\fP The SAK byte returned from \fBPICC_Select()\fP\&. 
.RE
.PP

.SS "MFRC522::PICC_Type MFRC522Extended::PICC_GetType (\fBTagInfo\fP * tag)\fR [static]\fP"
Get the PICC type\&.

.PP
\fBDevuelve\fP
.RS 4
PICC_Type 
.RE
.PP

.PP
\fBParámetros\fP
.RS 4
\fItag\fP The \fBTagInfo\fP returned from \fBPICC_Select()\fP\&. 
.RE
.PP

.SS "bool MFRC522Extended::PICC_IsNewCardPresent ()\fR [override]\fP, \fR [virtual]\fP"
Returns true if a PICC responds to PICC_CMD_REQA\&. Only 'new' cards in state IDLE are invited\&. Sleeping cards in state HALT are ignored\&.

.PP
\fBDevuelve\fP
.RS 4
bool 
.RE
.PP

.PP
Reimplementado de \fBMFRC522\fP\&.
.SS "MFRC522::StatusCode MFRC522Extended::PICC_PPS ()"
Transmits Protocol and Parameter Selection Request (PPS) without parameter 1

.PP
\fBDevuelve\fP
.RS 4
STATUS_OK on success, STATUS_??? otherwise\&. 
.RE
.PP

.SS "MFRC522::StatusCode MFRC522Extended::PICC_PPS (TagBitRates sendBitRate, TagBitRates receiveBitRate)"
Transmits Protocol and Parameter Selection Request (PPS)

.PP
\fBDevuelve\fP
.RS 4
STATUS_OK on success, STATUS_??? otherwise\&. 
.RE
.PP

.PP
\fBParámetros\fP
.RS 4
\fIsendBitRate\fP DS  
.br
\fIreceiveBitRate\fP DR 
.RE
.PP

.SS "bool MFRC522Extended::PICC_ReadCardSerial ()\fR [override]\fP, \fR [virtual]\fP"
Simple wrapper around PICC_Select\&. Returns true if a UID could be read\&. Remember to call \fBPICC_IsNewCardPresent()\fP, \fBPICC_RequestA()\fP or \fBPICC_WakeupA()\fP first\&. The read UID is available in the class variable uid\&.

.PP
\fBDevuelve\fP
.RS 4
bool 
.RE
.PP

.PP
Reimplementado de \fBMFRC522\fP\&.
.SS "MFRC522::StatusCode MFRC522Extended::PICC_RequestATS (\fBAts\fP * ats)"
Transmits a Request command for Answer To Select (ATS)\&.

.PP
\fBDevuelve\fP
.RS 4
STATUS_OK on success, STATUS_??? otherwise\&. 
.RE
.PP

.SS "MFRC522::StatusCode MFRC522Extended::PICC_Select (\fBUid\fP * uid, byte validBits = \fR0\fP)\fR [override]\fP, \fR [virtual]\fP"
Transmits SELECT/ANTICOLLISION commands to select a single PICC\&. Before calling this function the PICCs must be placed in the READY(*) state by calling \fBPICC_RequestA()\fP or \fBPICC_WakeupA()\fP\&. On success:
.IP "\(bu" 2
The chosen PICC is in state ACTIVE(*) and all other PICCs have returned to state IDLE/HALT\&. (Figure 7 of the ISO/IEC 14443-3 draft\&.)
.IP "\(bu" 2
The UID size and value of the chosen PICC is returned in *uid along with the SAK\&.
.PP

.PP
A PICC UID consists of 4, 7 or 10 bytes\&. Only 4 bytes can be specified in a SELECT command, so for the longer UIDs two or three iterations are used: UID size Number of UID bytes Cascade levels Example of PICC ======== =================== ============== =============== single 4 1 MIFARE Classic double 7 2 MIFARE Ultralight triple 10 3 Not currently in use?

.PP
\fBDevuelve\fP
.RS 4
STATUS_OK on success, STATUS_??? otherwise\&. 
.RE
.PP

.PP
\fBParámetros\fP
.RS 4
\fIuid\fP Pointer to Uid struct\&. Normally output, but can also be used to supply a known UID\&.  
.br
\fIvalidBits\fP The number of known UID bits supplied in *uid\&. Normally 0\&. If set you must also supply uid->size\&. 
.RE
.PP

.PP
Reimplementado de \fBMFRC522\fP\&.
.SS "MFRC522::StatusCode MFRC522Extended::TCL_Deselect (\fBTagInfo\fP * tag)"
Send an S-Block to deselect the card\&. 
.SS "MFRC522::StatusCode MFRC522Extended::TCL_Transceive (\fBTagInfo\fP * tag, byte * sendData, byte sendLen, byte * backData = \fRNULL\fP, byte * backLen = \fRNULL\fP)"
Send an I-Block (Application) 
.SS "MFRC522::StatusCode MFRC522Extended::TCL_TransceiveRBlock (\fBTagInfo\fP * tag, bool ack, byte * backData = \fRNULL\fP, byte * backLen = \fRNULL\fP)"
Send R-Block to the PICC\&. 

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para Sistema de seguridad en cámaras frigoríficas del código fuente\&.
